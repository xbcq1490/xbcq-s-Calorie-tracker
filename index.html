<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>xbcq's Calorie tracker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            margin: 0;
            padding: 0;
            background-color: #121212; /* Dark background for body */
            color: #E0E0E0; /* Light text color */
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            text-align: center;
            overscroll-behavior-y: contain;
        }

        #appContainer {
            background-color: #1E1E1E; /* Darker container background */
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(255, 235, 59, 0.08); /* Subtle yellow shadow */
            width: 100%;
            max-width: 600px;
            margin: 20px;
            box-sizing: border-box;
        }
        
        .app-title {
            color: #FFEB3B; /* Yellow accent for title */
            font-size: 2.2em;
            margin-bottom: 25px;
        }

        #apiKeySetup, #mainApp {
            padding: 10px;
        }

        #apiKeySetup h2, #mainApp h2, #mainApp h3, #mainApp h4 {
            color: #FFEB3B; /* Yellow accent for headers */
        }

        #apiKeySetup input[type="password"], 
        #targetCaloriesInput {
            width: calc(100% - 26px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #444;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
            background-color: #333;
            color: #E0E0E0;
            font-family: 'Poppins', sans-serif;
        }
        #apiKeySetup input[type="password"]:focus, 
        #targetCaloriesInput:focus {
            border-color: #FFEB3B;
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 235, 59, 0.3);
        }


        button { /* General button styling */
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
        }
        button:active {
            transform: translateY(1px);
        }

        /* Primary buttons */
        #saveApiKeyButton, #scanButton, #setTargetButton {
            background-color: #FFEB3B;
            color: #121212; /* Dark text on yellow button */
            font-weight: bold;
        }
        #saveApiKeyButton:hover, #scanButton:hover, #setTargetButton:hover {
            background-color: #FDD835; /* Slightly darker yellow on hover */
            box-shadow: 0 2px 8px rgba(255, 235, 59, 0.2);
        }


        #controls {
            margin-top: 30px;
            margin-bottom: 30px;
        }

        #scanButton {
            padding: 15px 30px;
            font-size: 18px;
            width: 80%;
            max-width: 320px;
        }
      
        #calorieDisplay {
            margin-bottom: 25px;
        }
        #calorieDisplay h2 {
            margin-top: 0;
            margin-bottom: 15px;
        }
        #calorieDisplay p.calorie-text {
            font-size: 1.3em;
            font-weight: 500; /* Poppins medium */
            color: #E0E0E0;
        }
        #calorieDisplay p.calorie-text span#currentCalories {
            color: #FFEB3B; 
            font-size: 1.5em;
        }
         #calorieDisplay p.calorie-text span#targetCalories {
            font-size: 1.1em;
            color: #aaa;
        }


        #calorieGaugeContainer {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #lastScannedNutrients {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: left;
        }
        #lastScannedNutrients h4 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        #lastScannedNutrients p {
            margin: 5px 0;
            font-size: 0.95em;
            color: #ccc;
        }
        #lastScannedNutrients p strong {
            color: #FFEB3B;
        }
        #lastScannedNutrients p span {
            color: #E0E0E0;
        }


        #foodLog {
            list-style-type: none;
            padding: 0;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            background-color: #2a2a2a;
        }

        #foodLog li {
            background-color: #333;
            padding: 10px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            font-size: 0.9em;
            border-left: 4px solid #FFEB3B;
            color: #ccc;
        }
        #foodLog li:last-child {
            margin-bottom: 0;
        }


        #loadingIndicator {
            text-align: center;
            padding: 20px;
        }
        .spinner {
            border: 5px solid #444; 
            border-top: 5px solid #FFEB3B; /* Yellow spinner accent */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #geminiError, #apiKeyError {
            margin-top: 15px;
            font-weight: 500; /* Poppins medium */
            color: #FF8A80; /* Light red for errors on dark theme */
            background-color: rgba(255, 138, 128, 0.1);
            padding: 10px;
            border-radius: 6px;
        }
        
        /* Camera View Styles */
        #cameraView {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw; 
            height: 100vh; 
            background-color: black;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #cameraFeed {
            width: 100%;
            height: 100%; 
            object-fit: cover;
        }
        
        #cameraControls {
            position: absolute;
            bottom: 30px; /* Positioned higher from the bottom */
            left: 50%;
            transform: translateX(-50%);
            width: auto; 
            display: flex;
            gap: 20px; /* Space between buttons */
            padding: 12px;
            background-color: rgba(0, 0, 0, 0.6); 
            border-radius: 12px;
            z-index: 1001; 
        }

        #cameraControls button {
            padding: 15px 25px;
            font-size: 18px;
            border-radius: 8px;
            font-weight: bold;
        }
        #captureButton {
            background-color: #FFEB3B; 
            color: #121212;
        }
        #captureButton:hover {
            background-color: #FDD835;
        }
        #cancelCameraButton {
            background-color: #555; 
            color: #E0E0E0;
        }
        #cancelCameraButton:hover {
            background-color: #666;
        }

    </style>
</head>
<body>
    <div id="appContainer">
        <h1 class="app-title">xbcq's Calorie tracker</h1>
        <div id="apiKeySetup" style="display: none;">
            <h2>Setup Gemini API Key</h2>
            <p>Please enter your Google AI Studio Gemini API Key:</p>
            <input type="password" id="apiKeyInput" placeholder="Enter API Key">
            <button id="saveApiKeyButton">Save Key & Start</button>
            <p id="apiKeyError" style="color: #FF8A80; display: none;"></p>
        </div>

        <div id="mainApp" style="display: none;">
            <div id="calorieDisplay">
                <h2>Daily Calorie Intake</h2>
                <div id="calorieGaugeContainer">
                    <svg id="calorieGauge" width="250" height="125"></svg>
                </div>
                <p class="calorie-text"><span id="currentCalories">0</span> / <span id="targetCalories">2000</span> kcal</p>
                <div>
                    <input type="number" id="targetCaloriesInput" value="2000" placeholder="Set Target (e.g., 2000)">
                    <button id="setTargetButton">Set Target</button>
                </div>
            </div>

            <div id="lastScannedNutrients" style="display: none;">
                <h4>Last Scanned Item Details:</h4>
                <p id="nutrientFoodName"><strong>Food:</strong> <span>N/A</span></p>
                <p id="nutrientWeight"><strong>Weight:</strong> <span>N/A</span></p>
                <p id="nutrientCarbs"><strong>Carbs:</strong> <span>N/A</span></p>
                <p id="nutrientProtein"><strong>Protein:</strong> <span>N/A</span></p>
            </div>

            <div id="controls">
                <button id="scanButton">Scan Food Item</button>
            </div>
            
            <div id="loadingIndicator" style="display: none;">
                <div class="spinner"></div>
                <p>Analyzing your food... please wait.</p>
            </div>
            <p id="geminiError" style="color: #FF8A80; display: none; text-align: center;"></p>

            <div id="logSection">
                <h3>Activity Log</h3>
                <ul id="foodLog">
                    </ul>
            </div>
        </div>

        <div id="cameraView" style="display: none;">
            <video id="cameraFeed" playsinline autoplay muted></video>
            <canvas id="photoCanvas" style="display:none;"></canvas>
            <div id="cameraControls">
                <button id="captureButton">Capture</button>
                <button id="cancelCameraButton">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const API_KEY_STORAGE_KEY = 'xbcqGeminiCalorieTrackerApiKey'; // Changed key to be specific
        const GEMINI_API_URL_BASE = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=';

        // DOM Elements
        let apiKeySetupDiv, mainAppDiv, apiKeyInput, saveApiKeyButton, apiKeyErrorP;
        let calorieGaugeSvg, currentCaloriesSpan, targetCaloriesSpan, targetCaloriesInput, setTargetButton;
        let scanButton, cameraViewDiv, cameraFeedVideo, captureButton, cancelCameraButton, photoCanvas, cameraControlsDiv;
        let foodLogUl, loadingIndicatorDiv, geminiErrorP, logSectionDiv;
        let lastScannedNutrientsDiv, nutrientFoodNameSpan, nutrientWeightSpan, nutrientCarbsSpan, nutrientProteinSpan;


        // App State
        let apiKey = '';
        let currentCalories = 0;
        let targetCalories = 2000;
        let foodHistory = []; 
        let mediaStream = null;

        document.addEventListener('DOMContentLoaded', () => {
            // Assign DOM Elements
            apiKeySetupDiv = document.getElementById('apiKeySetup');
            mainAppDiv = document.getElementById('mainApp');
            apiKeyInput = document.getElementById('apiKeyInput');
            saveApiKeyButton = document.getElementById('saveApiKeyButton');
            apiKeyErrorP = document.getElementById('apiKeyError');

            calorieGaugeSvg = document.getElementById('calorieGauge');
            currentCaloriesSpan = document.getElementById('currentCalories');
            targetCaloriesSpan = document.getElementById('targetCalories');
            targetCaloriesInput = document.getElementById('targetCaloriesInput');
            setTargetButton = document.getElementById('setTargetButton');
            
            scanButton = document.getElementById('scanButton');
            cameraViewDiv = document.getElementById('cameraView');
            cameraFeedVideo = document.getElementById('cameraFeed');
            captureButton = document.getElementById('captureButton');
            cancelCameraButton = document.getElementById('cancelCameraButton');
            photoCanvas = document.getElementById('photoCanvas');
            cameraControlsDiv = document.getElementById('cameraControls');

            foodLogUl = document.getElementById('foodLog');
            loadingIndicatorDiv = document.getElementById('loadingIndicator');
            geminiErrorP = document.getElementById('geminiError');
            logSectionDiv = document.getElementById('logSection');

            lastScannedNutrientsDiv = document.getElementById('lastScannedNutrients');
            nutrientFoodNameSpan = document.querySelector('#nutrientFoodName span');
            nutrientWeightSpan = document.querySelector('#nutrientWeight span');
            nutrientCarbsSpan = document.querySelector('#nutrientCarbs span');
            nutrientProteinSpan = document.querySelector('#nutrientProtein span');


            // Event Listeners
            saveApiKeyButton.addEventListener('click', saveApiKeyHandler);
            scanButton.addEventListener('click', openCameraHandler);
            captureButton.addEventListener('click', captureImageHandler);
            cancelCameraButton.addEventListener('click', closeCameraHandler);
            setTargetButton.addEventListener('click', updateTargetCaloriesHandler);

            loadData();
            checkApiKey();
        });

        function checkApiKey() {
            const storedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
            if (storedKey) {
                apiKey = storedKey;
                apiKeySetupDiv.style.display = 'none';
                mainAppDiv.style.display = 'block';
                initializeMainApp();
            } else {
                apiKeySetupDiv.style.display = 'block';
                mainAppDiv.style.display = 'none';
            }
        }

        function saveApiKeyHandler() {
            const key = apiKeyInput.value.trim();
            if (key) {
                apiKey = key;
                localStorage.setItem(API_KEY_STORAGE_KEY, key);
                apiKeyErrorP.style.display = 'none';
                checkApiKey();
            } else {
                apiKeyErrorP.textContent = 'API Key cannot be empty.';
                apiKeyErrorP.style.display = 'block';
            }
        }

        function initializeMainApp() {
            updateCalorieDisplay();
            updateFoodLog();
            logSectionDiv.style.display = foodHistory.length > 0 ? 'block' : 'none';
            // Check if there's saved last scanned data to display, or hide it
            const lastScanned = getLastScannedItemFromHistory();
            if (lastScanned) {
                displayLastScannedNutrients(lastScanned, false); // false: don't assume it's a new scan
            } else {
                lastScannedNutrientsDiv.style.display = 'none';
            }
        }
        
        function getLastScannedItemFromHistory() {
            // This is a simplified approach. For true "last scanned item"
            // persistence beyond the current session's foodHistory,
            // we'd need to store its details separately in localStorage.
            // For now, if foodHistory exists, we can infer the last item details
            // if they were stored with more than just calories.
            // The current foodHistory only stores name, calories, date.
            // So, this function won't be able to restore full nutrients on page load
            // unless we modify what `addCalories` and `saveData` store.
            // For now, lastScannedNutrients will only show after a new scan.
            return null; // Or implement more sophisticated storage for last full scan details
        }


        function updateTargetCaloriesHandler() {
            const newTarget = parseInt(targetCaloriesInput.value, 10);
            if (!isNaN(newTarget) && newTarget > 0 && newTarget < 50000) {
                targetCalories = newTarget;
                localStorage.setItem('targetCalories', targetCalories);
                updateCalorieDisplay();
            } else {
                alert("Please enter a valid target calorie amount (e.g., between 1 and 50000).");
            }
        }

        function updateCalorieDisplay() {
            currentCaloriesSpan.textContent = Math.round(currentCalories);
            targetCaloriesSpan.textContent = targetCalories;
            targetCaloriesInput.value = targetCalories;
            drawGauge(currentCalories, targetCalories);
        }

        function drawGauge(current, max) {
            const svgNS = "http://www.w3.org/2000/svg";
            calorieGaugeSvg.innerHTML = ''; 

            const width = parseFloat(calorieGaugeSvg.getAttribute('width'));
            const height = parseFloat(calorieGaugeSvg.getAttribute('height'));
            const strokeWidth = 22; // Slightly thicker
            const radius = (height - strokeWidth / 2) * 0.95; 
            const cx = width / 2;
            const cy = height - strokeWidth / 2; 

            const bgArc = document.createElementNS(svgNS, "path");
            const startX = cx - radius;
            const startY = cy;
            const endX = cx + radius;
            const endY = cy;
            
            bgArc.setAttribute("d", `M ${startX},${startY} A ${radius},${radius} 0 0 1 ${endX},${endY}`);
            bgArc.setAttribute("fill", "none");
            bgArc.setAttribute("stroke", "#444"); // Darker background for gauge
            bgArc.setAttribute("stroke-width", strokeWidth);
            bgArc.setAttribute("stroke-linecap", "round");
            calorieGaugeSvg.appendChild(bgArc);

            if (max > 0) {
                const percentage = Math.min(current / max, 1.1); // Allow to go slightly over for visual feedback
                
                const fgArc = document.createElementNS(svgNS, "path");
                const circumference = Math.PI * radius;
                fgArc.setAttribute("d", `M ${startX},${startY} A ${radius},${radius} 0 0 1 ${endX},${endY}`);
                fgArc.setAttribute("fill", "none");
                
                let progressColor = "#FFEB3B"; // Yellow
                if (percentage > 1) progressColor = "#FF6347"; // Tomato red if over target
                
                fgArc.setAttribute("stroke", progressColor);
                fgArc.setAttribute("stroke-width", strokeWidth);
                fgArc.setAttribute("stroke-linecap", "round");
                // Cap visual progress at 100% of the arc, even if percentage is > 1
                fgArc.setAttribute("stroke-dasharray", `${circumference * Math.min(percentage, 1)} ${circumference}`); 
                calorieGaugeSvg.appendChild(fgArc);
            }
        }

        function displayLastScannedNutrients(item, isNewScan = true) {
            if (!item) {
                lastScannedNutrientsDiv.style.display = 'none';
                return;
            }
            nutrientFoodNameSpan.textContent = item.name || 'N/A';
            nutrientWeightSpan.textContent = (item.weight_grams !== undefined ? `${item.weight_grams} g` : 'N/A');
            nutrientCarbsSpan.textContent = (item.carbs_grams !== undefined ? `${item.carbs_grams} g` : 'N/A');
            nutrientProteinSpan.textContent = (item.protein_grams !== undefined ? `${item.protein_grams} g` : 'N/A');
            lastScannedNutrientsDiv.style.display = 'block';

            // If it's a new scan, we could also store this 'lastFullItem' in localStorage
            // to be reloaded by initializeMainApp via getLastScannedItemFromHistory
            if (isNewScan) {
                localStorage.setItem('lastFullScannedItem', JSON.stringify(item));
            }
        }

        function addCalories(amount, foodItemDetails) { // foodItemDetails is now the full first item object
            currentCalories += amount; // amount here is total_estimated_calories_all_items
            
            // For logging, we use the name(s) from foodItemDetails or a summary
            let logName = "Scanned Food";
            if (foodItemDetails && foodItemDetails.name) {
                logName = foodItemDetails.name;
            } else if (foodItemDetails && Array.isArray(foodItemDetails.food_items) && foodItemDetails.food_items.length > 0) {
                 // If multiple items were processed and summarized before calling addCalories
                logName = foodItemDetails.food_items.map(fi => fi.name).join(', ');
            }

            foodHistory.push({ 
                name: logName, 
                calories: Math.round(amount), 
                date: new Date().toISOString(),
                // Optionally store the full details of the primary item if needed for log later
                // details: (foodItemDetails && foodItemDetails.name) ? foodItemDetails : null 
            });
            saveData();
            updateCalorieDisplay();
            updateFoodLog();
            logSectionDiv.style.display = 'block';

            if (foodItemDetails && foodItemDetails.name) { // If we have details for a single primary item
                displayLastScannedNutrients(foodItemDetails);
            } else if (foodItemDetails && Array.isArray(foodItemDetails.food_items) && foodItemDetails.food_items.length === 1) {
                // If the details object contains an array with one item
                displayLastScannedNutrients(foodItemDetails.food_items[0]);
            }
             else {
                // If multiple items or no specific item details to show, clear/hide nutrient display
                // or show summary if applicable. For now, just display for single primary item.
                const lastFullItem = JSON.parse(localStorage.getItem('lastFullScannedItem'));
                if (!lastFullItem && lastScannedNutrientsDiv) { // only hide if it's not already showing something persistent
                     // lastScannedNutrientsDiv.style.display = 'none'; 
                     // Decided to keep last scanned visible until next scan or day reset
                }
            }
        }

        function updateFoodLog() {
            foodLogUl.innerHTML = '';
            for (let i = foodHistory.length - 1; i >= 0; i--) {
                const item = foodHistory[i];
                const li = document.createElement('li');
                const date = new Date(item.date);
                li.textContent = `${item.name}: ${item.calories} kcal (${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})})`;
                foodLogUl.appendChild(li);
            }
            logSectionDiv.style.display = foodHistory.length > 0 ? 'block' : 'none';
        }

        function saveData() {
            localStorage.setItem('currentCalories', currentCalories);
            localStorage.setItem('foodHistory', JSON.stringify(foodHistory));
            localStorage.setItem('targetCalories', targetCalories);
            localStorage.setItem('lastLoggedDate', new Date().toISOString().split('T')[0]);
            // 'lastFullScannedItem' is saved in displayLastScannedNutrients for new scans
        }

        function loadData() {
            const savedCalories = localStorage.getItem('currentCalories');
            const savedHistory = localStorage.getItem('foodHistory');
            const savedTarget = localStorage.getItem('targetCalories');
            const lastLoggedDate = localStorage.getItem('lastLoggedDate');
            const today = new Date().toISOString().split('T')[0];

            if (lastLoggedDate !== today) {
                currentCalories = 0;
                foodHistory = [];
                targetCalories = savedTarget ? parseInt(savedTarget, 10) : 2000;
                localStorage.removeItem('lastFullScannedItem'); // Clear last scanned on new day
                saveData(); 
            } else {
                currentCalories = savedCalories ? parseFloat(savedCalories) : 0;
                foodHistory = savedHistory ? JSON.parse(savedHistory) : [];
                targetCalories = savedTarget ? parseInt(savedTarget, 10) : 2000;
                
                // Load and display last full scanned item if it exists for today
                const lastFullItem = JSON.parse(localStorage.getItem('lastFullScannedItem'));
                if (lastFullItem && lastScannedNutrientsDiv) { // check lastScannedNutrientsDiv exists
                    displayLastScannedNutrients(lastFullItem, false);
                } else if (lastScannedNutrientsDiv) {
                    lastScannedNutrientsDiv.style.display = 'none';
                }
            }
            targetCaloriesInput.value = targetCalories;
        }

        async function openCameraHandler() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("Camera access (getUserMedia) is not supported in your browser or not available on this page (needs HTTPS or localhost).");
                return;
            }
            try {
                mainAppDiv.style.display = 'none';
                cameraViewDiv.style.display = 'flex';
                document.body.style.overflow = 'hidden'; 

                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 } 
                    } 
                });
                cameraFeedVideo.srcObject = mediaStream;
                await cameraFeedVideo.play();
            } catch (err) {
                console.error("Error accessing camera: ", err);
                alert(`Could not access the camera. Please ensure permissions are granted and you are on HTTPS or localhost. Error: ${err.name} - ${err.message}`);
                closeCameraHandler();
            }
        }

        function closeCameraHandler() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            cameraFeedVideo.srcObject = null;
            cameraViewDiv.style.display = 'none';
            mainAppDiv.style.display = 'block';
            document.body.style.overflow = 'auto'; 
            geminiErrorP.style.display = 'none';
        }

        function captureImageHandler() {
            if (!mediaStream || !cameraFeedVideo.videoWidth) {
                console.error("Camera stream not available or video not ready.");
                alert("Camera not ready. Please try again.");
                return;
            }
            const context = photoCanvas.getContext('2d');
            photoCanvas.width = cameraFeedVideo.videoWidth;
            photoCanvas.height = cameraFeedVideo.videoHeight;
            
            context.drawImage(cameraFeedVideo, 0, 0, photoCanvas.width, photoCanvas.height);
            
            closeCameraHandler(); 

            const imageDataBase64 = photoCanvas.toDataURL('image/jpeg', 0.85).split(',')[1];
            
            loadingIndicatorDiv.style.display = 'block';
            geminiErrorP.style.display = 'none';

            callGeminiAPI(imageDataBase64);
        }

        async function callGeminiAPI(base64ImageData) {
            const fullApiUrl = GEMINI_API_URL_BASE + apiKey;

            const prompt = `You are an expert nutritionist. Analyze the food item(s) in this image.
Estimate the following for each distinct food item you can identify:
1. A concise name for the food item (e.g., "Medium Apple", "Chicken Breast Piece").
2. Total estimated weight in grams (e.g., 150).
3. Estimated protein in grams.
4. Estimated carbohydrates in grams.
5. Estimated total calories (kcal).

If there are multiple food items, provide details for each.
Your entire response MUST be a single, valid JSON object.
The JSON object should have a key "food_items" which is an array of objects. Each object in the array represents a detected food item and must contain these exact keys: "name" (string), "weight_grams" (number), "protein_grams" (number), "carbs_grams" (number), and "calories" (number).
Also, include a key "total_estimated_calories_all_items" (number) in the main JSON object, representing the sum of calories from all detected items.

Example for a single item:
{
  "food_items": [
    {
      "name": "Medium Apple",
      "weight_grams": 150,
      "protein_grams": 0.5,
      "carbs_grams": 20,
      "calories": 95
    }
  ],
  "total_estimated_calories_all_items": 95
}

If no food is clearly identifiable or you cannot make a reasonable estimation, return an empty "food_items" array and 0 for "total_estimated_calories_all_items".
Do not include any text outside the JSON object, no conversational introductions, and no markdown formatting like \`\`\`json or \`\`\`. Only the raw JSON object.`;

            const requestBody = {
                "contents": [
                    {
                        "parts": [
                            { "text": prompt },
                            {
                                "inline_data": {
                                    "mime_type": "image/jpeg",
                                    "data": base64ImageData
                                }
                            }
                        ]
                    }
                ],
                "generationConfig": {
                    "responseMimeType": "application/json",
                }
            };

            try {
                const response = await fetch(fullApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                loadingIndicatorDiv.style.display = 'none';

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => response.text());
                    console.error('Gemini API Error Response:', errorBody);
                    let errorMessage = `Error from Gemini API: ${response.status} ${response.statusText}`;
                    if (typeof errorBody === 'object' && errorBody && errorBody.error && errorBody.error.message) {
                        errorMessage += ` - ${errorBody.error.message}`;
                    } else if (typeof errorBody === 'string') {
                         errorMessage += ` - ${errorBody}`;
                    }
                    displayGeminiError(errorMessage);
                    return;
                }

                const responseData = await response.json(); 
                console.log('Gemini API Success Response:', responseData);
                
                let nutritionInfo;
                if (responseData.candidates && responseData.candidates.length > 0 &&
                    responseData.candidates[0].content && responseData.candidates[0].content.parts &&
                    responseData.candidates[0].content.parts.length > 0 &&
                    responseData.candidates[0].content.parts[0].text) {
                    try {
                        let jsonString = responseData.candidates[0].content.parts[0].text.trim();
                        if (jsonString.startsWith("```json")) {
                            jsonString = jsonString.substring(7, jsonString.length - 3).trim();
                        } else if (jsonString.startsWith("```")) {
                            jsonString = jsonString.substring(3, jsonString.length - 3).trim();
                        }
                        nutritionInfo = JSON.parse(jsonString);
                    } catch (e) {
                         console.error("Error parsing Gemini JSON from text field:", e);
                         displayGeminiError("AI returned data, but it was not in the expected JSON format.");
                         return;
                    }
                } else if (typeof responseData === 'object' && responseData.food_items) {
                    nutritionInfo = responseData;
                } else {
                     displayGeminiError("Received an unexpected response structure from AI.");
                     console.error("Unexpected Gemini Response structure: ", responseData);
                     return;
                 }

                if (nutritionInfo && nutritionInfo.food_items && nutritionInfo.food_items.length > 0) {
                    const totalCaloriesFromResponse = nutritionInfo.total_estimated_calories_all_items;
                    const firstItemDetails = nutritionInfo.food_items[0]; // For display purposes

                    if (typeof totalCaloriesFromResponse === 'number' && totalCaloriesFromResponse >= 0) {
                        // Pass the first item's details to addCalories, which will then call displayLastScannedNutrients
                        addCalories(totalCaloriesFromResponse, firstItemDetails); 
                        if (totalCaloriesFromResponse === 0 && nutritionInfo.food_items.length > 0) {
                            alert("AI identified food items but estimated 0 total calories. This has been logged.");
                        }
                    } else {
                        displayGeminiError("AI response missing or invalid total calorie count.");
                    }

                } else if (nutritionInfo && nutritionInfo.food_items && nutritionInfo.food_items.length === 0) {
                     displayGeminiError("AI analyzed the image but could not identify any food items or estimate calories.");
                     lastScannedNutrientsDiv.style.display = 'none'; // Hide if no food found
                } else {
                    displayGeminiError("AI could not process the image or returned an invalid response format.");
                }

            } catch (error) {
                loadingIndicatorDiv.style.display = 'none';
                console.error('Error calling or processing Gemini API response:', error);
                displayGeminiError(`Network error or problem with API call: ${error.message}. Check console for details.`);
            }
        }

        function displayGeminiError(message) {
            geminiErrorP.textContent = message;
            geminiErrorP.style.display = 'block';
            setTimeout(() => {
                geminiErrorP.style.display = 'none';
            }, message.toLowerCase().includes("error") ? 8000 : 5000);
        }

    </script>
</body>
</html>
